# 1. JPA 소개

- **ORM(Object-Relational Mapping) 프레임워크**는 객체와 관계형 데이터베이스 간의 차이(패러다임의 불일)를 중간에서 해결함.

- **JPA(Java Persistence API)** 는 자바의 ORM 기술 표준임. 반복적인 CRUD SQL을 알아서 처리하고 실행 시점에 자동으로 SQL을 생성하여 실행함.

- JPA를 사용하면 개발자는 SQL을 직접 작성하지 않고 어떤 SQL이 실행될지 생각만 하면 됨. 애플리케이션을 SQL이 아닌 **객체 중심**으로 개발하여 생산성과 유지보수성을 향상시킴.

![JDBC API와 SQL](https://github.com/user-attachments/assets/ee4417ce-3491-4b56-857d-3f4329ba6f13)

## 1.1 SQL을 직접 다룰 때 발생하는 문제점

### 1.1.1 반복, 반복 그리고 반복

- 객체를 데이터베이스에 CRUD하려면 너무 많은 SQL과 JDBC API를 코드로 작성해야 함.
- 데이터 접근 계층(DAO) 개발은 지루함과 반복의 연속임.

### 1.1.2 SQL에 의존적인 개발

- 객체가 연관된 다른 객체를 사용할 수 있을지 전적으로 사용하는 SQL에 달려 있음.
- 데이터 접근 계층을 사용해서 SQL을 숨겨도 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 함.
- 개발자들이 엔티티를 신뢰하고 사용할 수 없음.
- 물리적으로 SQL과 JDBC API를 데이터 접근 계층에 숨겨도 논리적으로는 엔티티와 강한 의존관계를 가짐.

> **요약**
> - 진정한 의미의 계층 분할이 어려움.
> - 엔티티를 신뢰할 수 없음.
> - SQL에 의존적인 개발을 피하기 어려움.

### 1.1.3 JPA와 문제 해결

JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때 개발자가 직접 SQL을 작성하지 않고 JPA가 제공하는 API를 사용하면 됨.

**JPA의 CRUD API**
- 저장 기능: `persist()` 메소드
- 조회 기능: `find()` 메소드
- 수정 기능: 별도의 메소드 없음, 객체 조회 후 값 변경
- 삭제 기능: `remove()` 메소드

## 1.2 패러다임의 불일치

- 비즈니스 요구사항을 정의한 도메인 모델도 객체로 모델링하면 객체지향 언어가 가진 장점들을 활용할 수 있음. 하지만 정의한 모델을 저장할 때 문제가 발생함.
- 객체는 속성(필드)과 기능(메소드)를 가짐. 객체가 복잡하면 객체의 상태를 저장하기 어려움.
- 자바는 **직렬화**와 **역직렬화** 기능을 지원하지만, 직렬화된 객체를 검색하기 어려운 문제가 있음. 따라서 **관계형 데이터베이스**에 객체를 저장하는데, 관계형 데이터베이스는 데이터 중심 구조화, 집합적인 사고를 요구하고 객체지향의 추상화, 상속, 다형성 같은 개념이 없음.

### 1.2.1 상속

- 객체는 상속을 가지고 있지만 테이블은 상속이 없음.
- 데이터베이스 모델링의 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 유사한 형태로 테이블을 설계 가능함.
- JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결함.

### 1.2.2 연관관계

- **객체**는 **참조**를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회함.
- **테이블**은 **외래키**를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회함.
- 참조를 사용하는 객체와 외래키를 사용하는 관계형 데이터베이스 사이의 패러다임 불일치는 극복하기 어려움.
- 객체는 참조가 있는 방향으로만 조회할 수 있음.
- JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결함.

### 1.2.3 객체 그래프 탐색

- **객체 그래프 탐색**: 객체에서 회원이 소속된 팀을 조회할 때 참조를 사용해서 연관된 팀을 찾는 것
- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해지는 제약이 있음.
- JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있음.
- JPA는 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미루는 **지연 로딩** 기능을 제공함.

### 1.2.4 비교

데이터베이스는 기본키의 값으로 각 로우(row)를 구분함. 객체는 동일성(identity) 비교와 동등성(equality) 비교 방법이 있음.

- **동일성 비교**: `==` 비교, 객체 인스턴스의 주소 값을 비교함.
- **동등성 비교**: `equals()` 메소드를 사용해서 객체 내부의 값을 비교함.

데이터베이스의 같은 로우를 조회했지만 객체의 동일성 비교에는 실패함. JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장하여 동일성 비교에 성공함.

## 1.3 JPA란 무엇인가?

![JPA](https://github.com/user-attachments/assets/c1e2624b-6f5f-4277-9d03-5065c12a170a)

- **JPA**는 애플리케이션과 JDBC 사이에서 동작함.
- **ORM**은 객체와 관계형 데이터베이스를 매핑함.
- ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결함.
- 자바는 하이버네이트, EclipseLink, DataNucleus 등 다양한 ORM 프레임워크가 있는데, 하이버네이트 프레임워크가 가장 많이 사용됨.

### 1.3.1 JPA 소개

- JPA는 자바 ORM 기술에 대한 API 표준 명세임.
- JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 함.
- JPA라는 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있음.

**JPA 버전별 특징**

- **JPA 1.0(JSR 220) 2006년**: 복합키와 연관관계 기능이 부족함.
- **JPA 2.0(JSR 317) 2009년**: 대부분의 ORM 기능을 포함하고 JPA Criteria가 추가됨.
- **JPA 2.1(JSR 338) 2013년**: 스토어드 프로시저 접근, 컨버터(Converter), 엔티티 그래프 기능이 추가됨.
- **JPA 2.2(JSR 338) 2017년**: Java 8 Stream API 지원과 java.time API(LocalDate, LocalDateTime 등) 매핑이 추가됨.
- **Jakarta Persistence 3.0 2020년**: 패키지명이 javax.persistence에서 jakarta.persistence로 변경됨.
- **Jakarta Persistence 3.1 2022년**: UUID 지원 개선과 JPQL 수학/날짜 함수(CEILING, EXP, FLOOR 등)가 추가됨.
- **Jakarta Persistence 3.2 2024년**: 프로그래밍 방식 설정, Java Record 지원, JPQL Set 연산(union, intersect, except)이 추가됨.

### 1.3.2 왜 JPA를 사용해야 하는가?

- **생산성**: JPA의 기능을 사용하면 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있음.
- **유지보수**: 개발자가 작성해야 했던 SQL과 JDBC API 코드를 JPA가 대신 처리해주므로 유지보수해야 하는 코드 수가 줄어듦.
- **패러다임의 불일치 해결**: JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결함.
- **성능**: JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공함.
- **데이터 접근 추상화와 벤더 독립성**: JPA는 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 함.
- **표준**: 표준을 사용하면 다른 구현 기술로 손쉽게 변경할 수 있음.