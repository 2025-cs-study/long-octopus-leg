# 13. 웹 애플리케이션과 영속성 관리
- 트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 달라 발생하는 **준영속 상태**와 **지연 로딩 예외**가 핵심 내용임.

## 13.1 트랜잭션 범위의 영속성 컨텍스트
- **스프링 컨테이너의 기본 전략**: 스프링 환경에서는 트랜잭션이 시작될 때 영속성 컨텍스트가 생성되고, 트랜잭션이 종료될 때 영속성 컨텍스트도 함께 종료됨.
- 즉, 영속성 컨텍스트의 생존 범위와 트랜잭션의 범위가 정확히 일치함.(같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다름.)
- 이로 인해 트랜잭션이 없는 프리젠테이션 계층(컨트롤러, 뷰)에서는 엔티티가 준영속 상태가 됨.

## 13.2 준영속 상태와 지연 로딩
- **준영속 상태와 지연 로딩의 문제점**: 트랜잭션이 종료된 컨트롤러나 뷰 계층에서, 지연 로딩(`FetchType.LAZY`)으로 설정된 연관 엔티티를 조회하려고 시도하면
`LazyInitializationException` 예외가 발생함. ➡️ 이는 엔티티를 실제로 로딩해야 할 영속성 컨텍스트가 이미 닫혔기 때문임.
- 이 문제를 **해결**하는 방법으로는 뷰를 미리 로딩하는 방법(글로벌 페치 전략 수정, JPQL 페치 조인, 강제로 초기화)과 OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법이 있음.


- **글로벌 페치 전략 수정**: 가장 간단한 해결책은 연관관계 매핑의 페치 전략을 `EAGER`로 변경하는 것이지만,
이는 사용하지 않는 엔티티까지 미리 조회하여 성능 저하를 유발하는 **N+1 문제**의 원인이 되므로 권장되지 않음.
- **JPQL 페치 조인**: 가장 추천되는 해결 방법으로, JPQL 쿼리 작성 시 `JOIN FETCH`를 사용하여 특정 화면이나 로직에 필요한 연관 엔티티를 한 번의 쿼리로 함께 조회하는 방식임.
- **강제로 초기화**: 서비스 계층에서 트랜잭션이 활성 상태일 때, `Hibernate.initialize()` 메소드를 호출하거나 해당 엔티티의 메소드(예: `order.getMember().getName()`)를 직접 호출하여 프록시 객체를 강제로 초기화하는 방법임.
- **FACADE 계층 추가**: 프레젠테이션 계층(컨트롤러, 뷰)을 위한 별도의 FACADE 계층을 두어, 해당 계층에서 필요한 엔티티를 명시적으로 초기화하고 DTO로 변환하여 반환하는 방법임. 영속성 관리를 서비스 계층과 분리할 수 있음.

## 13.3 OSIV
- **OSIV(Open Session In View)** 는 영속성 컨텍스트의 생존 범위를 뷰가 렌더링될 때까지 연장하여 `LazyInitializationException`을 해결하는 기법임.
- **과거 OSIV: 요청 당 트랜잭션**: 클라이언트의 요청이 들어올 때 트랜잭션을 시작하고, 응답이 나갈 때 트랜잭션을 종료하는 방식임. 컨트롤러나 뷰 같은 프리젠테이션 계층이 엔티티를 변경할 수 있다는 단점이 있음.
- 이 문제의 해결책으로는 엔티티를 읽기 전용 인터페이스로 제공, 엔티티 레핑, DTO만 반환하는 방법이 있으나 코드량이 상당이 증가한다는 문제점이 생김.
- **스프링 OSIV: 비즈니스 계층 트랜잭션**: 영속성 컨텍스트는 요청 전체에 걸쳐 유지되지만 트랜잭션은 비즈니스(서비스) 계층에서만 적용됨. 또한 모든 변경은 트랜잭션 안에서만 이루어짐.

## 13.4 너무 엄격한 계층
- 아키텍처에서 계층(Controller, Service, Repository)을 나누는 것은 중요하지만, 너무 엄격하게 적용할 필요는 없음.
- 단순히 조회만 하는 간단한 기능의 경우 서비스 계층을 생략하고 컨트롤러가 리포지토리를 직접 호출하여 DTO로 변환하는 것이 더 실용적일 수 있음.