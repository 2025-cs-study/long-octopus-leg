# 16. 트랜잭션과 락, 2차 캐시

## 16.1 트랜잭션과 락

### 트랜잭션과 격리 수준
- 트랜잭션은 ACID(원자성, 일관성, 격리성, 지속성)를 보장해야 함.

| 격리 수준 | 특징 | 발생 가능한 문제점 |
|:---|:---|:---|
| **READ UNCOMMITTED**<br>(커밋되지 않은 읽기) | - 가장 낮은 격리 수준<br>- 트랜잭션이 처리 중이고 **아직 커밋하지 않은 데이터**를 다른 트랜잭션이 읽을 수 있음<br>- 성능은 가장 좋지만 데이터 정합성에 심각한 문제가 발생할 수 있음 | - **Dirty Read**<br>- **Non-Repeatable Read**<br>- **Phantom Read** |
| **READ COMMITTED**<br>(커밋된 읽기) | - **대부분의 DB(Oracle, PostgreSQL 등)의 기본값**<br>- **커밋한 데이터만** 읽을 수 있음<br>- Dirty Read는 방지되지만, 조회 중에 데이터가 변경될 수 있음 | - **Non-Repeatable Read**<br>- **Phantom Read** |
| **REPEATABLE READ**<br>(반복 가능한 읽기) | - **MySQL(InnoDB)의 기본값**<br>- 트랜잭션이 시작된 시점의 스냅샷을 보게 하여, 트랜잭션 내에서 **반복 조회 시 항상 동일한 결과**를 보장함 | - **Phantom Read** |
| **SERIALIZABLE**<br>(직렬화 가능) | - 가장 엄격한 격리 수준<br>- 트랜잭션을 순차적으로 실행하는 것처럼 완벽하게 격리함 | - **동시성 처리 성능이 급격히 떨어짐** |



- 격리 수준이 낮으면 `데이터 정합성 문제`가 발생하고, 높으면 `동시성 성능`이 떨어짐.
    - **Dirty Read**: 다른 트랜잭션이 수정 중이고 아직 커밋하지 않은 데이터를 읽는 문제.
    - **Non-Repeatable Read**: 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 그 사이에 다른 트랜잭션이 값을 수정/삭제하여 결과가 달라지는 문제.
    - **Phantom Read**: 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 그 사이에 다른 트랜잭션이 새로운 데이터를 삽입하여 결과 집합이 달라지는 문제.

### 🙂 낙관적 락과 🙁 비관적 락 기초

- **🙂 낙관적 락**
  - 충돌이 거의 발생하지 않을 것이라고 가정함.
  - 데이터베이스의 락 기능을 사용하지 않고, JPA가 제공하는 버전 관리 기능을 사용함. ➡️ 애플리케이션이 제공하는 락 기능임.
- **🙁 비관적 락**
  - 충돌이 발생할 것이라고 가정함.
  - 데이터베이스가 제공하는 락 기능(`select for update`)을 사용함.
- **두 번의 갱실 분실 문제**
  - 데이터베이스의 트랜잭션 범위를 넘어서는 문제.
  - 마지막 커밋만 인정하기, 최초 커밋만 인정하기, 충돌하는 갱신 내용 병합하기 방법이 있음.

### @Version
- **🙂 낙관적 락**을 사용하기 위해 엔티티에 사용하는 어노테이션임.
- `Long`, `Integer`, `Short`, `Timestamp` 타입에 적용 가능.
- 엔티티를 수정할 때마다 버전이 자동으로 하나씩 증가하며, 수정 시점의 버전이 조회 시점과 다르면 예외(`OptimisticLockException`)가 발생함. ➡️ 최초의 커밋만 인정하기가 적용됨.

### JPA 락 사용
- `em.lock()`, `em.find()`, `Query.setLockMode()`를 통해 락 모드를 지정할 수 있음.

### JPA 🙂 낙관적 락 옵션
- 버전을 사용하기 때문에 버전이 있어야 함. 락 옵션으로 세밀하게 제어가 가능함.
    - `NONE`: 락 옵션 없이 `@Version`만 있어도 동작함. (수정 시점에만 버전 체크)
    - `OPTIMISTIC`: 조회 시점부터 트랜잭션이 끝날 때까지 다른 트랜잭션에 의해 변경되지 않음을 보장함. (조회만 해도 버전 체크)
    - `OPTIMISTIC_FORCE_INCREMENT`: 엔티티를 수정하지 않아도 강제로 버전을 증가시킴. (논리적인 단위의 변경 처리에 유용, ex. 게시물 첨부파일만 변경되어도 게시물 버전 증가)

### JPA 🙁 비관적 락 옵션
- 데이터베이스가 제공하는 락 기능(`select for update`)을 사용하고, 스칼라 타입을 조회할 때 사용할 수 있고, 데이터 수정 즉시 트랜잭션 충돌을 감지할 수 있음.
    - `PESSIMISTIC_WRITE`: 가장 일반적인 비관적 락으로, 데이터베이스의 `select for update` 쿼리를 사용함. (쓰기 락)
    - `PESSIMISTIC_READ`: 데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용함. (잘 사용하지 않음)
    - `PESSIMISTIC_FORCE_INCREMENT`: 비관적 락 중 유일하게 버전 정보를 사용함. 버전 정보를 강제적으로 증가시킴.

### 비관적 락과 타임아웃
- 비관적 락을 사용할 때 락을 획득할 때까지 무한정 기다리는 것을 방지하기 위해 타임아웃 시간을 설정할 수 있음.

## 16.2 2차 캐시

### 1차 캐시와 2차 캐시

- 데이터를 메모리에 캐시해서 데이터베이스 접근 횟수를 줄이면 애플리케이션 성능을 획기적으로 개선할 수 있음.
- **1차 캐시**: `EntityManager` 범위(트랜잭션 범위)의 캐시. 트랜잭션이 끝나면 사라지므로 성능 개선 효과가 제한적임.
- **2차 캐시**: `EntityManagerFactory` 범위(애플리케이션 범위)의 캐시. 애플리케이션 종료 시까지 유지되며, 모든 트랜잭션이 공유함.

### JPA 2차 캐시 기능
- `@Cacheable`: 엔티티에 이 어노테이션을 붙여 2차 캐시 사용 여부를 지정함.
- 2차 캐시는 동시성 문제를 해결하기 위해, 객체 자체를 반환하지 않고 **객체의 복사본**을 반환함.
- `javax.persistence.sharedCache.mode` 설정을 통해 캐시 모드(ALL, NONE, ENABLE_SELECTIVE 등)를 제어함. ➡️ 보통은 `ENABLE_SELECTIVE`를 사용함.

### 하이버네이트와 EHCACHE 적용
- 하이버네이트는 2차 캐시를 인터페이스로 제공하고, EHCACHE 같은 구현체를 연결해서 사용함.
- **엔티티 캐시, 컬렉션 캐시, 쿼리 캐시** 기능을 제공함.
- 쿼리 캐시는 쿼리와 파라미터 정보를 키로 사용하여 쿼리 결과를 캐싱함. (쿼리 대상 테이블에 변경이 일어나면 캐시가 무효화되므로 수정이 빈번한 테이블에는 비효율적임)
- 엔티티 캐시는 엔티티 정보를 모두 캐시하지만 쿼리 캐시와 컬렉션 캐시는 결과 집합의 식별자 값만 캐시함.
  따라서 쿼리 캐시나 컬렉션 캐시만 사용하고 대상 엔티티에 엔티티 캐시를 적용하지 않으면 성능상 심각한 문제가 발생할 수 있음.