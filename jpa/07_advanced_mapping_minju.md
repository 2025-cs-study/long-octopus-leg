# 7. 고급 매핑

<img width="1250" height="830" alt="JPA 고급 매핑" src="https://github.com/user-attachments/assets/b3514c39-8bdf-40b3-977e-fdef055a2702" />

## 7.1 상속 관계 매핑

관계형 데이터베이스에는 객체지향 언어의 **상속 개념이 없음**. ORM에서 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 **슈퍼타입 서브타입 관계**를 매핑하는 것임.

#### 슈퍼타입 서브타입 논리 모델을 실제 물리 모델(테이블)로 구현하는 3가지 방법

1. **각각의 테이블로 변환** → 조인 전략
2. **통합 테이블로 변환** → 단일 테이블 전략
3. **서브타입 테이블로 변환** → 구현 클래스마다 테이블 전략

### 7.1.1 조인 전략 (Joined Strategy)

- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본키를 받아서 **기본키 + 외래키**로 사용함.
- **조회**할 때 자주 사용되며, **타입을 구분하는 컬럼**이 필요함.
- **어노테이션**: `@PrimaryKeyJoinColumn`, `@DiscriminatorColumn`, `@DiscriminatorValue`

| **장점** | **단점** |
|---------|---------|
| - 테이블이 정규화됨<br>- 외래키 참조 무결성 제약조건 활용 가능<br>- 저장공간을 효율적으로 사용 | - 조회 시 조인이 많이 사용되어 성능 저하 발생<br>- 조회 쿼리가 복잡함<br>- 데이터 등록 시 INSERT SQL을 두 번 실행 |

### 7.1.2 단일 테이블 전략 (Single-Table Strategy)

- 테이블을 하나만 사용하고, **구분 컬럼**으로 어떤 자식 데이터가 저장되었는지 구분함.
- **구분 컬럼을 꼭 사용해야 함.** (`@DiscriminatorColumn`)
- `@DiscriminatorValue`를 지정하지 않으면 기본으로 엔티티 이름을 사용함.

| **장점** | **단점** |
|---------|---------|
| - 조인이 필요없어 조회 성능이 빠름<br>- 조회 쿼리가 단순함 | - 자식 엔티티가 매핑한 컬럼은 모두 null 허용 필요<br>- 테이블이 커질 수 있어 상황에 따라 조회 성능 저하 발생 |

### 7.1.3 구현 클래스마다 테이블 전략 (Table-per-Concrete-Class Strategy)

- 자식 엔티티마다 테이블을 만들고, 자식 테이블 각각에 필요한 컬럼이 모두 있음.
- **구분 컬럼을 사용하지 않음.**
- 데이터베이스 설계자와 ORM 전문가 모두 **추천하지 않는 전략**임.

| **장점** | **단점** |
|---------|---------|
| - 서브 타입을 구분해서 처리할 때 효과적<br>- not null 제약조건 사용 가능 | - 여러 자식 테이블을 함께 조회할 때 성능이 느림 (UNION 사용)<br>- 자식 테이블을 통합해서 쿼리하기 힘듦 |

## 7.2 @MappedSuperclass

- 부모 클래스가 테이블과 매핑하지 않고 자식 클래스에게 **매핑 정보만 제공**하고 싶을 때 사용함.
- 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정보를 상속할 목적으로만 사용함.
- `@MappedSuperclass`로 지정한 클래스는 엔티티가 아니므로 `em.find()`나 JPQL에서 사용할 수 없음.
- 직접 생성해서 사용할 일이 거의 없으므로 **추상 클래스**로 만드는 것을 권장함.

## 7.3 복합키와 식별 관계 매핑

### 7.3.1 식별 관계 vs 비식별 관계

데이터베이스 테이블 사이 관계는 외래키가 기본키에 포함되는지 여부에 따라 구분됨.

- **식별 관계(Identifying Relationship)**: 부모 테이블의 기본키를 내려받아서 자식 테이블의 **기본키 + 외래키**로 사용함.
- **비식별 관계(Non-Identifying Relationship)**: 부모 테이블의 기본키를 받아서 자식 테이블의 **외래키로만** 사용함.

    - **필수적 비식별 관계(Mandatory)**: 외래키에 NULL을 허용하지 않음. (연관관계 필수)

    - **선택적 비식별 관계(Optional)**: 외래키에 NULL을 허용함. (연관관계 선택)

### 7.3.2 복합키: 비식별 관계 매핑

JPA는 복합키를 지원하기 위해 **2가지 방법**을 제공함.
- `@IdClass` (관계형 데이터베이스에 가까움)
- `@EmbeddedId` (객체지향에 가까움)

#### @IdClass 사용 시 식별자 클래스 조건
- 식별자 클래스의 속성명 = 엔티티에서 사용하는 식별자의 속성명
- `Serializable` 인터페이스 구현
- `equals`, `hashCode` 구현
- 기본 생성자 필요
- 식별자 클래스는 public

#### @EmbeddedId 사용 시 식별자 클래스 조건
- `@Embeddable` 어노테이션 필요
- `Serializable` 인터페이스 구현
- `equals`, `hashCode` 구현
- 기본 생성자 필요
- 식별자 클래스는 public

> **중요**: 복합키는 `equals()`와 `hashCode()`를 필수로 구현해야 함.

### 7.3.3 복합키: 식별 관계 매핑

식별 관계에서 자식 테이블은 부모 테이블의 기본키를 포함해서 복합키를 구성해야 하므로 `@IdClass`나 `@EmbeddedId`를 사용해서 식별자를 매핑해야 함.

- **@IdClass와 식별 관계**: 식별자 매핑인 `@Id`와 연관관계 매핑인 `@ManyToOne`을 같이 사용함.
- **@EmbeddedId와 식별 관계**: 식별 관계로 사용할 연관관계의 속성에 `@MapsId`를 사용함.

### 7.3.4 비식별 관계로 구현

식별 관계의 복합키를 사용한 것보다 **매핑도 쉽고 코드도 단순**함. 복합키가 없으므로 복합키 클래스를 만들지 않아도 됨.

### 7.3.5 일대일 식별 관계

자식 테이블의 기본키 값으로 부모 테이블의 기본키 값만 사용함. 부모 테이블의 기본키가 복합키가 아니면 자식 테이블의 기본키는 복합키로 구성하지 않아도 됨.

### 7.3.6 식별, 비식별 관계의 장단점

| | **장점** | **단점** |
|---------|---------|---------|
| **식별 관계** | - 기본키 인덱스를 활용하기 좋음<br>- 상위 테이블들의 기본키 컬럼을 하위 테이블이 가지고 있어 특정 상황에서 조인 없이 검색 완료 가능 | - 부모 테이블의 기본키를 자식 테이블로 전파하면서 자식 테이블의 기본키 컬럼이 점점 늘어남<br>- 2개 이상의 컬럼을 합해서 복합 기본키를 만들어야 하는 경우가 많음<br>- 비즈니스 의미가 있는 자연키 컬럼을 조합하는 경우가 많음<br>- 테이블 구조가 유연하지 못함 |
| **비식별 관계** | - 비즈니스와 전혀 관계없는 대리키를 주로 사용<br>- 식별자 컬럼이 하나여서 쉽게 매핑 가능<br>- 필수적 비식별 관계는 NOT NULL로 내부 조인만 사용해도 됨 | - 선택적 비식별 관계는 NULL을 허용하므로 조인할 때 외부 조인을 사용해야 함 |

## 7.4 조인 테이블

#### 데이터베이스 테이블의 연관관계를 설계하는 2가지 방법

1. **조인 컬럼 사용(외래키)**: 테이블 간 관계는 조인 컬럼(외래키 컬럼)을 사용해서 관리함.
2. **조인 테이블 사용(테이블 사용)**: 별도의 테이블을 사용해서 연관관계를 관리함.

- 객체와 테이블을 매핑할 때 조인 컬럼은 `@JoinColumn`으로 매핑하고 조인 테이블은 `@JoinTable`로 매핑함.
- 조인 테이블은 주로 **다대다 관계**를 일대다, 다대일 관계로 풀어내기 위해 사용하지만 일대일, 일대다, 다대일 관계에서도 사용할 수 있음.

**조인 테이블 매핑 유형**
- **일대다 조인 테이블**: 조인 테이블의 컬럼 중 다(N)와 관련된 컬럼에 유니크 제약조건을 걸어야 함.
- **다대일 조인 테이블**: 일대다에서 방향만 반대임.
- **다대다 조인 테이블**: 조인 테이블의 두 컬럼을 합해서 하나의 복합 유니크 제약조건을 걸어야 함.

## 7.5 엔티티 하나에 여러 테이블 매핑

`@SecondaryTable`을 사용하면 **한 엔티티에 여러 테이블**을 매핑할 수 있음.

**@SecondaryTable 속성**
- `@SecondaryTable.name`: 매핑할 다른 테이블의 이름
- `@SecondaryTable.pkJoinColumns`: 매핑할 다른 테이블의 기본키 컬럼 속성

> **권장사항**: `@SecondaryTable`을 사용해서 두 테이블을 하나의 엔티티에 매핑하는 것보다 **테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것**을 권장함.