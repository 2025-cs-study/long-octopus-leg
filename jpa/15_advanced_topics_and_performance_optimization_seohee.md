# 15. 고급 주제와 성능 최적화

## 15.1 예외 처리

- **JPA 표준 예외 정리**: JPA 표준 예외는 모두 `javax.persistence.PersistenceException`의 자식 클래스이며, `RuntimeException`을 상속받는 비검사 예외(Unchecked Exception)임.
  - **트랜잭션 롤백을 표시하는 예외**: 심각한 오류로 복구가 불가능하다고 판단하여 트랜잭션을 강제로 롤백함.
  - **트랜잭션 롤백을 표시하지 않는 예외**: 비교적 덜 심각한 오류로, 개발자가 트랜잭션을 커밋할지 롤백할지 판단하여 처리할 수 있음.
- **스프링 프레임워크의 JPA 예외 변환**: 스프링은 데이터 접근 계층의 예외를 추상화하여 특정 기술(JPA, JDBC 등)에 의존하지 않는 예외 처리를 제공함.
  - `PersistenceExceptionTranslationPostProcessor`를 스프링 빈으로 등록하면 JPA의 예외를 스프링이 추상화한 예외로 자동 변환해줌.
- **트랜잭션 롤백 시 주의사항**: 트랜잭션이 롤백되면 데이터베이스는 복구되지만, 영속성 컨텍스트의 엔티티는 수정된 상태로 남아있어 **데이터 불일치**가 발생함.
  - 따라서 롤백된 영속성 컨텍스트를 계속 사용해야 한다면 반드시 `em.clear()`로 초기화하거나 새로운 영속성 컨텍스트를 사용해야 안전함.
  - **기본 전략(트랜잭션 범위) vs OSIV**:
    - **기본 전략**: 트랜잭션 종료 시 영속성 컨텍스트도 함께 종료되므로 문제가 발생하지 않음.
    - **OSIV**: 트랜잭션이 롤백되어도 영속성 컨텍스트가 살아있으므로, 초기화하지 않고 재사용할 경우 데이터 정합성 문제가 발생할 수 있음.

## 15.2 엔티티 비교

- **영속성 컨텍스트가 같을 때**: 엔티티의 **동일성(`==`)** 비교가 보장됨. 1차 캐시에 있는 같은 인스턴스를 반환하기 때문임.
- **영속성 컨텍스트가 다를 때**: 동일성(`==`) 비교가 실패함. 따라서 비즈니스 키를 활용한 **동등성(`equals()`)** 비교를 사용해야 함. 

## 15.3 프록시 심화 주제

- **영속성 컨텍스트와 프록시**: 영속성 컨텍스트는 엔티티의 동일성을 보장하기 위해, 이미 프록시로 조회된 엔티티에 대해서는 `em.find()`를 호출해도 프록시를 반환함. 반대로 이미 원본 엔티티가 조회된 상태라면 `em.getReference()`를 호출해도 원본 엔티티를 반환함.
- **프록시 타입 비교**: 프록시는 원본 엔티티를 상속받은 자식 클래스임. 따라서 타입을 비교할 때는 `==` 대신 `instanceof`를 사용해야 함.
- **프록시 동등성 비교**: 프록시 객체를 대상으로 `equals()`를 구현할 때는 주의가 필요함.
  - `member.name`와 같이 필드에 직접 접근하면 프록시 객체의 필드는 비어있으므로 `null`이 반환될 수 있음.
  - 반드시 접근자 메소드(Getter)를 사용하여 데이터를 조회해야 프록시가 초기화되면서 값을 가져옴.
  - 프록시 타입의 비교는 `==` 대신 `instanceof`를 사용해야 함.
- **상속관계와 프록시**: 프록시를 사용할 때 부모 타입으로 조회하면, 실제 인스턴스가 자식 타입이라도 부모 타입의 프록시가 생성되어 `instanceof` 연산이나 다운캐스팅이 동작하지 않는 문제가 발생할 수 있음.
  - 해결 방법으로는 JPQL로 대상 직접 조회, 하이버네이트가 제공하는 프록시 벗기기, 기능을 위한 별도의 인터페이스 제공, 비지터 패턴 사용이 있음.
## 15.4 성능 최적화

- **N+1 문제**: JPA 성능 문제의 가장 흔한 원인임. 1번의 쿼리로 조회한 엔티티와 연관된 엔티티를 조회하기 위해 N번의 추가 쿼리가 발생하는 현상임.
  - **해결 방법**: **페치 조인(Fetch Join)** 이 가장 일반적이며, 하이버네이트 `@BatchSize` 설정을 통해 IN 쿼리로 묶어서 조회하는 방법, @Fetch(FetchMode.SUBSELECT)를 사용하는 방법이 있음.
- **읽기 전용 쿼리의 성능 최적화**: 데이터를 수정할 일이 없는 단순 조회 쿼리의 경우 메모리와 속도를 최적화할 수 있음.
  - **스칼라 타입 조회**: 엔티티가 아닌 스칼라 타입으로 모든 필드를 조회하는 것, 스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않음.
  - **읽기 전용 트랜잭션**: 스프링의 `@Transactional(readOnly = true)`를 사용하면, 트랜잭션 커밋 시 플러시를 호출하지 않고 스냅샷 비교(변경 감지)도 하지 않아 성능이 향상됨.
  - **읽기 전용 쿼리 힌트 사용**: `org.hibernate.readOnly`를 사용하면 엔티티를 읽기 전용으로 조회할 수 있음. 읽기 전용이라 스냅샷을 보관하지 않아 메모리 사용량을 최적화할 수 있음.
  - **트랜잭션 밖에서 읽기**: 트랜잭션 없이 엔티티를 조회한다는 뜻임. 트랜잭션을 사용하지 않으면 플러시가 일어나지 않아서 조회 성능이 향상됨.
- **배치 처리**: 수만 건 이상의 데이터를 처리할 때는 영속성 컨텍스트에 엔티티가 쌓여 메모리 부족 오류가 발생할 수 있음.
  - JPA 페이징 배치 처리, 하이버네이트 scroll 사용, 하이버네이트 무상태 세션 사용 방법이 있음.
- **SQL 쿼리 힌트 사용**: 하이버네이트의 `addQueryHint` 등을 사용함.
- **트랜잭션을 지원하는 쓰기 지연과 성능 최적화**: `hibernate.jdbc.batch_size` 속성을 설정하면, SQL을 바로 실행하지 않고 모아두었다가 한 번에 전송하여 네트워크 호출 횟수를 획기적으로 줄일 수 있고,
데이터베이스 로우에 락이 걸리는 시간을 최소화할 수 있음.