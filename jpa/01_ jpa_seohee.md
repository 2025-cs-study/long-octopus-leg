# 1. JPA 소개

## 1.1 SQL을 직접 다룰 때 발생하는 문제점
- CRUD SQL 코드를 반복해서 작성해야 함
- 엔티티가 수정되면 관련된 모든 SQL을 수정해야 함
  ➡️ SQL에 의존적인 개발을 피하기 어렵고, 진정한 의미의 계층 분할이 어려움
- 엔티티를 신뢰할 수 없음 (실제로 어떤 필드가 조회되는지 SQL을 확인해야 함)

## 1.2 패러다임 불일치
### 상속
- 객체는 상속관계를 가지지만, 관계형 데이터베이스는 상속 개념이 없음
- 슈퍼타입 서브타입 관계로 모델링해야 하는 복잡함

### 연관관계
- 객체는 참조(reference)를 사용하여 연관된 객체에 접근
- 테이블은 외래키(Foreign Key)를 사용하여 다른 테이블과 연관관계를 맺음
- 객체에 외래키 값을 저장하면 연관된 객체에 바로 접근할 수 없음

### 객체 그래프 탐색
- SQL을 직접 다루면 처음 실행한 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해짐
- 자유로운 객체 그래프 탐색이 불가능함

### 비교하기
- SQL을 직접 다루면 동일성(==) 비교가 실패함
- 동등성(equals) 비교만 가능

## 1.3 JPA란 무엇인가?
### JPA (Java Persistence API)
- 자바 진영의 ORM(Object-Relational Mapping) 기술 표준 명세
- 인터페이스의 모음 (구현체: Hibernate, EclipseLink, DataNucleus 등)
- Hibernate가 가장 대중적인 구현체

### JPA 사용의 장점

#### 1. 생산성
- 반복적인 CRUD SQL 작성 불필요
- 간단한 설정만으로 데이터베이스 매핑 가능

#### 2. 유지보수
- 엔티티 필드 추가/변경 시 관련 SQL을 모두 수정할 필요 없음
- SQL에 의존적이지 않은 개발 가능

#### 3. 패러다임 불일치 해결
- 상속, 연관관계, 객체 그래프 탐색 문제를 JPA가 해결
- 지연 로딩과 즉시 로딩을 통한 유연한 객체 그래프 탐색

#### 4. 성능 최적화
- 1차 캐시: 같은 트랜잭션 내에서 같은 객체 재사용
- 지연 로딩: 실제 사용 시점에 데이터 조회
- 쓰기 지연: 트랜잭션 커밋 시점에 SQL 실행

#### 5. 데이터베이스 벤더 독립성
- 데이터베이스 방언(Dialect) 지원
- Oracle에서 MySQL로 변경해도 코드 수정 불필요